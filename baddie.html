<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BaddiSphere - Ultimate Version</title>

  <!-- Mobile-friendly viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    /* ---------- Overall Styling ---------- */
    html, body {
      margin: 0;
      background: #000;
      font-family: "Helvetica Neue", Arial, sans-serif;
      font-size: 16px;
      color: #fff;
    }
    /* Make all buttons bigger (font-size + padding) for easy tapping */
    button {
      font-size: 1.3em;
      padding: 0.78em;
    }

    /* ---------- Welcome/Oath Page Overlay ---------- */
    #welcomeOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.7);
      z-index: 3000;

      /* NEW: allow vertical scrolling if content is too tall */
      overflow-y: auto;
      /* optional padding for breathing room */
      padding: 1em;
    }
    /* Use responsive width + new max-height & internal scroll */
    #welcomeBox {
      background: #222;
      border: 2px solid #555;
      border-radius: 8px;
      padding: 1.5em;
      width: 90%;
      max-width: 500px;
      margin: 2em auto;
      text-align: center;

      /* NEW: keep the box from exceeding screen height */
      max-height: 90vh;
      overflow-y: auto;
    }

    #oathContainer {
      margin-top: 1em;
      font-size: 0.9em;
      line-height: 1.4em;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      padding: 0.8em;
      font-style: italic;
      text-align: left;
    }
    #welcomeNames {
      margin-top: 1.2em;
      text-align: left;
      font-size: 0.9em;
    }
    .nameRow {
      margin-bottom: 0.7em;
    }
    .nameRow label {
      display: inline-block;
      width: 130px;
      color: #ccc;
    }
    .nameRow input {
      background: #333;
      border: 1px solid #555;
      color: #fff;
      padding: 2px 4px;
      border-radius: 4px;
      width: 200px;
    }

    /* ---------- Weighted Category Choice Modal ---------- */
    #weightChoiceOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.7);
      z-index: 2000;
    }
    #weightChoiceBox {
      background: #222;
      border: 2px solid #555;
      border-radius: 8px;
      padding: 1.5em;
      width: 90%;
      max-width: 500px;
      margin: 0 auto;
      text-align: center;
    }
    #categoryOptions {
      margin-top: 1em;
      text-align: left;
    }
    .categoryOption {
      margin-bottom: 1em;
      line-height: 1.4em;
      padding: 0.6em;
      background: rgba(255,255,255,0.07);
      border-radius: 5px;
    }
    #pickCategoryBtn {
      margin-top: 1em;
      width: 100%;
      background: #555;
      border: none;
      border-radius: 5px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
    }
    #pickCategoryBtn:hover {
      background: #777;
    }

    /* ---------- Progress Bar at Bottom ---------- */
    #bottomBar {
      position: fixed;  
      bottom: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: rgba(20,20,20,0.8);
      display: flex;
      align-items: center;
      padding: 0 1em;
      box-sizing: border-box;
      z-index: 999;
    }
    #progressContainer {
      flex: 1;
      margin-right: 1em;
      background: #333;
      height: 10px;
      border-radius: 5px;
      overflow: hidden;
      position: relative;
    }
    #progressBar {
      background: #0f0;
      width: 0;
      height: 100%;
      transition: width 0.3s;
    }
    #progressText {
      margin-right: 2em;
      white-space: nowrap;
      font-weight: bold;
    }

    /* ---------- Name Fields (top corners) ---------- */
    #beholderContainer,
    #appleContainer {
      display: none;
    }

    /* ---------- Modal for Question Input ---------- */
    #modalOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 5000;
    }
    #modalBox {
      background: #222;
      border: 2px solid #555;
      border-radius: 8px;
      padding: 1em;
      width: 340px;
    }
    .sliderContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 1em 0;
    }
    .sliderLine {
      display: flex;
      align-items: center;
      width: 100%;
      margin-bottom: 4px;
    }
    .sliderLine label {
      flex: 0 0 120px;
      text-align: right;
      padding-right: 8px;
    }
    .sliderLine input[type="range"] {
      flex: 1;
      margin: 0 8px;
      -webkit-appearance: slider-horizontal;
      accent-color: pink;
    }
    .sliderLine .valueDisplay {
      width: 30px;
      text-align: center;
      margin-left: 8px;
      font-weight: bold;
    }
    .minMaxMarks {
      display: flex;
      justify-content: space-between;
      width: 100%;
      font-size: 0.75em;
      color: #aaa;
      margin-top: -4px;
      padding: 0 6px;
    }
    #modalButtons {
      display: flex;
      justify-content: flex-end;
      margin-top: 1em;
    }
    #modalButtons button {
      margin-left: 1em;
      background: #555;
      border: none;
      border-radius: 5px;
      color: #fff;
      cursor: pointer;
      font-weight: bold;
    }
    #modalButtons button:hover {
      background: #777;
    }

    /* ---------- Bonus Modal ---------- */
    #bonusModalOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 5000;
    }
    #bonusModalBox {
      background: #222;
      border: 2px solid #555;
      border-radius: 8px;
      padding: 1em;
      width: 400px;
    }
    #bonusModalBox textarea {
      width: 100%;
      height: 100px;
      resize: none;
      margin-bottom: 1em;
      padding: 5px;
      font-family: inherit;
      font-size: 1em;
    }

    /* ---------- CSS2D Labels ---------- */
    .label {
      font-size: 16px;
      background: rgba(50,50,50,0.7);
      padding: 4px 8px;
      border-radius: 4px;
      white-space: nowrap;
      pointer-events: none;
      transition: none;
      font-weight: bold;
    }

    /* ---------- Final Results Overlay ---------- */
    #finalResultOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      background: rgba(0,0,0,0.9);
      z-index: 2000;
      color: #fff;
      padding: 20px;
      overflow-y: auto;
    }
    #finalResultBox {
      background: #222;
      border: 2px solid #fff;
      border-radius: 8px;
      padding: 20px;
      width: 90%;
      max-width: 600px;
      text-align: center;
      margin: 0 auto;
    }
    #finalScore {
      font-size: 2.5em;
      color: #0f0;
      font-weight: bold;
    }

    /* ---------- Confetti Canvas ---------- */
    #confettiCanvas {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      z-index: 3000;
    }
    /* ---------- Bottom-Right Label ---------- */
    #zaddyRights {
      position: fixed;
      bottom: 4px;
      right: 10px;
      color: #ccc;
      font-size: 0.8em;
      z-index: 9999;
    }

    /* Tick mark datalists for 5 or 10 values */
    datalist option {
      color: pink;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <!-- NEW WELCOME PAGE with Oath -->
  <div id="welcomeOverlay">
    <div id="welcomeBox">
      <h2>Welcome to Baddiology</h2>
      <p style="font-size:0.9em;">
        Before proceeding, please enter both names and swear upon the Baddie Oath:
      </p>
      <div id="welcomeNames">
        <div class="nameRow">
          <label>Your Name:</label>
          <input id="welcomeBeholder" type="text" placeholder="Your Name" />
        </div>
        <div class="nameRow">
          <label>Their Name:</label>
          <input id="welcomeApple" type="text" placeholder="Target's Name" />
        </div>
      </div>
      <div id="oathContainer">
        <p>
          "I, [Name], the baddie in control, solemnly swear upon the principles of Baddiology 
          to uphold truth, fairness, and unwavering consistency in all matters of rating 
          those who crave my presence.
        </p>
        <p>
          I vow to remain true to my own tastes, to never waver in my standards, 
          no matter the sweet temptations.
        </p>
        <p>
          I swear to honor the essence of moisture, to recognize both the tangible 
          and the intangible, and never to mislead or be misled in my quest for the ideal partner.
        </p>
        <p>
          Above all, I pledge to be true to myself, for only through authenticity 
          can these ratings hold meaning in my life.
        </p>
        <p>
          So it is spoken, so it shall be ranked, and may we sail forth to new Londons"
        </p>
      </div>
      <button id="swearOathBtn" style="
        margin-top: 1em;
        width: 100%;
        background: #555;
        border: none;
        border-radius: 5px;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
      ">
        Swear by Baddie Oath?
      </button>
    </div>
  </div>

  <!-- Weighted Category Choice Modal -->
  <div id="weightChoiceOverlay">
    <div id="weightChoiceBox">
      <h2>Pick Your prefered Category</h2>
      <p style="font-size:0.9em;">
        Each section normally accounts for 20% of the final rating except one special category, 
        which gets 40%. Select which one you prefer:
      </p>
      <div id="categoryOptions">
        <div class="categoryOption">
          <input type="radio" name="weightedCat" value="Moisture Scale" id="optMoisture" checked />
          <label for="optMoisture" id="labelMoisture">Moisture Scale (40%)</label>
          <br /><em style="color:#999;">Face, build, height, overall attractiveness</em>
        </div>
        <div class="categoryOption">
          <input type="radio" name="weightedCat" value="Emotionality" id="optEmotion" />
          <label for="optEmotion" id="labelEmotion">Emotionality (20%)</label>
          <br /><em style="color:#999;">Annoyance factor, stability, intelligence, humor</em>
        </div>
        <div class="categoryOption">
          <input type="radio" name="weightedCat" value="Nezessities" id="optNecess" />
          <label for="optNecess" id="labelNecess">Nezessities (20%)</label>
          <br /><em style="color:#999;">Style, voice, homies, red flags</em>
        </div>
        <div class="categoryOption">
          <input type="radio" name="weightedCat" value="Husband Material" id="optHusband" />
          <label for="optHusband" id="labelHusband">Husband Material (20%)</label>
          <br /><em style="color:#999;">Loyalty, providing, family, respects my grind</em>
        </div>
      </div>
      <button id="pickCategoryBtn">Confirm & Start</button>
    </div>
  </div>

  <!-- Bottom Bar & Progress -->
  <div id="bottomBar">
    <div id="progressText">Questions: 0 / 16 answered</div>
    <div id="progressContainer">
      <div id="progressBar"></div>
    </div>
  </div>

  <!-- Name Fields (Hidden) -->
  <div id="beholderContainer">
    <label>Baddie:
      <input id="beholderInput" type="text" placeholder="Your name..." />
    </label>
  </div>
  <div id="appleContainer">
    <label>Target:
      <input id="appleInput" type="text" placeholder="Their name..." />
    </label>
  </div>

  <!-- Tick marks for sliders (5 and 10) with visible labels/numbers -->
  <datalist id="ticks5">
    <option value="1" label="1"></option>
    <option value="2" label="2"></option>
    <option value="3" label="3"></option>
    <option value="4" label="4"></option>
    <option value="5" label="5"></option>
  </datalist>
  <datalist id="ticks10">
    <option value="1" label="1"></option>
    <option value="2" label="2"></option>
    <option value="3" label="3"></option>
    <option value="4" label="4"></option>
    <option value="5" label="5"></option>
    <option value="6" label="6"></option>
    <option value="7" label="7"></option>
    <option value="8" label="8"></option>
    <option value="9" label="9"></option>
    <option value="10" label="10"></option>
  </datalist>

  <!-- Modal for Question Input -->
  <div id="modalOverlay">
    <div id="modalBox">
      <h2 id="modalTitle">Question</h2>
      <div class="sliderContainer">
        <div class="sliderLine">
          <label id="questionName"></label>
          <input type="range" id="questionSlider" min="1" value="1" />
          <span class="valueDisplay" id="questionValue">1</span>
        </div>
        <div class="minMaxMarks" id="minMaxMarks">
          <span>1</span><span>10</span>
        </div>
      </div>
      <div id="modalButtons">
        <button id="cancelBtn">Cancel</button>
        <button id="saveBtn">Save</button>
      </div>
    </div>
  </div>

  <!-- Bonus Modal -->
  <div id="bonusModalOverlay">
    <div id="bonusModalBox">
      <h2>Bonus Points</h2>
      <p style="font-size:0.9em;">Enter your missing reasoning for extra 0.5 points (optional):</p>
      <textarea id="bonusText"></textarea>
      <div id="bonusModalButtons">
        <button id="cancelBonusBtn">Cancel</button>
        <button id="submitBonusBtn">Submit Bonus</button>
      </div>
    </div>
  </div>

  <!-- Final Results Overlay -->
  <div id="finalResultOverlay"></div>

  <!-- Bottom-Right Label -->
  <div id="zaddyRights">All rights reserved: Zaddy Incorporated</div>

  <!-- Confetti Canvas -->
  <canvas id="confettiCanvas"></canvas>

  <!-- Three.js & Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/renderers/CSS2DRenderer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/geometries/TextGeometry.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

  <script>
    /* 
      Baddiology with full (questions_5 + questions_10) arrays,
      ensuring 4 spikes per category no matter which is weighted.
    */

    // Oath Overlay
    const welcomeOverlay = document.getElementById('welcomeOverlay');
    const swearOathBtn   = document.getElementById('swearOathBtn');
    const welcomeBeholder = document.getElementById('welcomeBeholder');
    const welcomeApple    = document.getElementById('welcomeApple');
    
    // Hidden name fields used in final scoring
    const beholderInput = document.getElementById('beholderInput');
    const appleInput    = document.getElementById('appleInput');

    swearOathBtn.addEventListener('click', () => {
      let bVal = welcomeBeholder.value.trim();
      let aVal = welcomeApple.value.trim();
      if(!bVal || !aVal){
        alert("Please enter both names before proceeding.");
        return;
      }
      // Transfer to hidden fields so final results can pick them up
      beholderInput.value = bVal;
      appleInput.value    = aVal;

      // Hide oath overlay, show Weighted Category overlay
      welcomeOverlay.style.display = 'none';
      document.getElementById('weightChoiceOverlay').style.display = 'flex';
    });

    // Category data
    let categories = [];
    let wedgeAngles = [];
    let totalQuestions = 0;
    let weightedCategoryName = "";
    let bonusAsked = false;
    let bonusCompleted = false;
    let bonusPoints = 0;
    let bonusText = "";

    // Base categories with question_10 + question_5 arrays
    const baseCategoryData = {
      "Moisture Scale": {
        name: "Moisture Scale", color: 0xff00ff,
        questions_10: [
          { name: "Face Card", max: 10, value: null },
          { name: "Build Preference", max: 10, value: null },
          { name: "Height Preference", max: 10, value: null },
          { name: "Overall Attractiveness", max: 10, value: null }
        ],
        questions_5: [
          { name: "Face Card", max: 5, value: null },
          { name: "Build Preference", max: 5, value: null },
          { name: "Height Preference", max: 5, value: null },
          { name: "Overall Attractiveness", max: 5, value: null }
        ]
      },
      "Emotionality": {
        name: "Emotionality", color: 0x0099ff,
        questions_10: [
          { name: "Annoyance Factor", max: 10, value: null },
          { name: "Emotional Stability", max: 10, value: null },
          { name: "Intelligence", max: 10, value: null },
          { name: "Humor", max: 10, value: null }
        ],
        questions_5: [
          { name: "Annoyance Factor", max: 5, value: null },
          { name: "Emotional Stability", max: 5, value: null },
          { name: "Intelligence", max: 5, value: null },
          { name: "Humor", max: 5, value: null }
        ]
      },
      "Nezessities": {
        name: "Nezessities", color: 0x00ff88,
        questions_10: [
          { name: "Style", max: 10, value: null },
          { name: "Voice", max: 10, value: null },
          { name: "Homies", max: 10, value: null },
          { name: "Red Flags", max: 10, value: null }
        ],
        questions_5: [
          { name: "Style", max: 5, value: null },
          { name: "Voice", max: 5, value: null },
          { name: "Homies", max: 5, value: null },
          { name: "Red Flags", max: 5, value: null }
        ]
      },
      "Husband Material": {
        name: "Husband Material", color: 0xffcc00,
        questions_10: [
          { name: "Loyalty", max: 10, value: null },
          { name: "Providing", max: 10, value: null },
          { name: "Family", max: 10, value: null },
          { name: "Respect for the Grind", max: 10, value: null }
        ],
        questions_5: [
          { name: "Loyalty", max: 5, value: null },
          { name: "Providing", max: 5, value: null },
          { name: "Family", max: 5, value: null },
          { name: "Respect for the Grind", max: 5, value: null }
        ]
      }
    };

    // Weighted category labels
    const labelMoisture = document.getElementById('labelMoisture');
    const labelEmotion  = document.getElementById('labelEmotion');
    const labelNecess   = document.getElementById('labelNecess');
    const labelHusband  = document.getElementById('labelHusband');

    const radioEls = [
      { el: document.getElementById('optMoisture'), labelEl: labelMoisture },
      { el: document.getElementById('optEmotion'),  labelEl: labelEmotion },
      { el: document.getElementById('optNecess'),   labelEl: labelNecess },
      { el: document.getElementById('optHusband'),  labelEl: labelHusband }
    ];
    radioEls.forEach(r => {
      r.el.addEventListener('change', () => {
        if (r.el.checked) {
          radioEls.forEach(rr => {
            if (rr.el.value === r.el.value) {
              rr.labelEl.textContent = `${rr.el.value} (40%)`;
            } else {
              rr.labelEl.textContent = `${rr.el.value} (20%)`;
            }
          });
        }
      });
    });

    // Weighted Category Confirmation
    const pickCategoryBtn = document.getElementById('pickCategoryBtn');
    const weightChoiceOverlay = document.getElementById('weightChoiceOverlay');
    pickCategoryBtn.addEventListener('click', () => {
      const chosen = document.querySelector('input[name="weightedCat"]:checked');
      if (!chosen) return;
      weightedCategoryName = chosen.value;

      categories = [];
      wedgeAngles = [];

      // Weighted => questions_10 (40% wedge),
      // Others => questions_5 (20% wedge)
      Object.keys(baseCategoryData).forEach(catKey => {
        const baseCat = baseCategoryData[catKey];
        if (catKey === weightedCategoryName) {
          wedgeAngles.push(Math.PI * 0.8);
          categories.push({
            name: baseCat.name,
            color: baseCat.color,
            questions: JSON.parse(JSON.stringify(baseCat.questions_10))
          });
        } else {
          wedgeAngles.push(Math.PI * 0.4);
          categories.push({
            name: baseCat.name,
            color: baseCat.color,
            questions: JSON.parse(JSON.stringify(baseCat.questions_5))
          });
        }
      });

      totalQuestions = categories.reduce((s, cat) => s + cat.questions.length, 0);
      weightChoiceOverlay.style.display = 'none';
      initBaddiSphere();
    });

    // Three.js + label stuff
    let scene, camera, renderer, labelRenderer, controls;
    let wedgeGroup, wedgeGroupWireframe, textGroup, baddiTextMesh;
    let starMaterial;
    let spikeData = [];
    let bonusGroup, bonusSphere;
    let blowUpActive = false;
    let blowUpStartTime = null;
    let myConfetti;
    const finalResultOverlay = document.getElementById('finalResultOverlay');

    function initBaddiSphere() {
      initScene();
      buildSphere();
      buildBaddieText();
      buildStars();
      buildBonusSphere();
      initRaycaster();
      myConfetti = confetti.create(document.getElementById('confettiCanvas'), { resize: true, useWorker: true });
      animate();
      updateProgress();
    }

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 40);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(0, 20, 20);
      scene.add(dirLight);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      controls = new THREE.OrbitControls(camera, renderer.domElement);

      labelRenderer = new THREE.CSS2DRenderer();
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.domElement.style.position = 'absolute';
      labelRenderer.domElement.style.top = '0';
      labelRenderer.domElement.style.pointerEvents = 'none';
      document.body.appendChild(labelRenderer.domElement);

      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('orientationchange', onWindowResize, false);
    }

    function buildSphere() {
      wedgeGroup = new THREE.Group();
      scene.add(wedgeGroup);
      wedgeGroupWireframe = new THREE.Group();
      wedgeGroup.add(wedgeGroupWireframe);

      let phiStart = 0;
      const sphereRadius = 8;
      const spikeOuterRadius = sphereRadius + 3;

      for (let i = 0; i < categories.length; i++) {
        const cat = categories[i];
        const phiLength = wedgeAngles[i];
        const wedgeGeom = new THREE.SphereGeometry(sphereRadius, 32, 32, phiStart, phiLength);
        const wedgeMat = new THREE.MeshStandardMaterial({
          color: cat.color,
          transparent: true,
          opacity: 0.65,
          metalness: 0.2,
          roughness: 0.2,
          side: THREE.DoubleSide,
          depthWrite: false
        });
        const wedgeMesh = new THREE.Mesh(wedgeGeom, wedgeMat);
        wedgeMesh.raycast = () => {}; // not clickable
        wedgeGroup.add(wedgeMesh);

        const wireframeMat = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.2, transparent: true });
        wedgeGroupWireframe.add(new THREE.LineSegments(wedgeGeom, wireframeMat));

        // Category label
        const catLabelEl = document.createElement('div');
        catLabelEl.className = 'label';
        catLabelEl.textContent = cat.name;
        const catLabelObj = new THREE.CSS2DObject(catLabelEl);
        const midPhi = phiStart + phiLength / 2;
        const labelTheta = 1.0; // slight tilt from top
        const lx = sphereRadius * Math.sin(labelTheta) * Math.cos(midPhi);
        const ly = sphereRadius * Math.cos(labelTheta);
        const lz = sphereRadius * Math.sin(labelTheta) * Math.sin(midPhi);
        catLabelObj.position.set(lx, ly, lz);
        wedgeGroup.add(catLabelObj);

        // Build spikes
        const stepTheta = Math.PI / (cat.questions.length + 1);
        cat.questions.forEach((q, qIndex) => {
          const spikeTheta = stepTheta * (qIndex + 1);
          // Spikes are 10% bigger
          const coneGeom = new THREE.ConeGeometry(1.1, 3.3, 16);
          coneGeom.rotateX(Math.PI * 0.5);

          const spikeMat = new THREE.MeshStandardMaterial({
            color: cat.color,
            emissive: cat.color,
            emissiveIntensity: 0.4
          });
          const spikeMesh = new THREE.Mesh(coneGeom, spikeMat);

          const sx = spikeOuterRadius * Math.sin(spikeTheta) * Math.cos(midPhi);
          const sy = spikeOuterRadius * Math.cos(spikeTheta);
          const sz = spikeOuterRadius * Math.sin(spikeTheta) * Math.sin(midPhi);
          spikeMesh.position.set(sx, sy, sz);

          // Orient spike outward
          const outward = spikeMesh.position.clone().multiplyScalar(2);
          spikeMesh.lookAt(outward);
          wedgeGroup.add(spikeMesh);

          // Spike label
          const spikeLabelEl = document.createElement('div');
          spikeLabelEl.className = 'label';
          spikeLabelEl.textContent = q.name;
          const spikeLabelObj = new THREE.CSS2DObject(spikeLabelEl);
          spikeLabelObj.position.set(0, 0, 2.0);
          spikeMesh.add(spikeLabelObj);

          // Save spike data
          spikeData.push({
            categoryIndex: i,
            questionIndex: qIndex,
            mesh: spikeMesh,
            labelObj: spikeLabelObj
          });
        });

        phiStart += phiLength;
      }
    }

    function buildBaddieText(){
      textGroup = new THREE.Group();
      scene.add(textGroup);

      const loader = new THREE.FontLoader();
      loader.load('https://cdn.jsdelivr.net/npm/three@0.136.0/examples/fonts/helvetiker_regular.typeface.json', font => {
        const textGeo = new THREE.TextGeometry('BADDIOLOGY', {
          font: font,
          size: 2,
          height: 0.3,
          curveSegments: 12
        });
        textGeo.center();
        const textMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          metalness: 0.5,
          roughness: 0.2,
          emissive: 0xffffff,
          emissiveIntensity: 0.2
        });
        baddiTextMesh = new THREE.Mesh(textGeo, textMat);
        baddiTextMesh.position.set(0, 14, 0);
        textGroup.add(baddiTextMesh);
      });
    }

    let starCount = 400;
    function buildStars(){
      const starGeometry = new THREE.BufferGeometry();
      const starPositions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++){
        const r = 200;
        starPositions[i*3]   = (Math.random() - 0.5) * 2 * r;
        starPositions[i*3+1] = (Math.random() - 0.5) * 2 * r;
        starPositions[i*3+2] = (Math.random() - 0.5) * 2 * r;
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1,
        sizeAttenuation: true,
        transparent: true
      });
      const starPoints = new THREE.Points(starGeometry, starMaterial);
      scene.add(starPoints);
    }

    function buildBonusSphere(){
      bonusGroup = new THREE.Group();
      scene.add(bonusGroup);

      const bonusGeom = new THREE.SphereGeometry(1.5, 32, 32);
      const bonusMat = new THREE.MeshStandardMaterial({
        color: 0xFFD700,
        emissive: 0xFFD700,
        emissiveIntensity: 0.5
      });
      bonusSphere = new THREE.Mesh(bonusGeom, bonusMat);
      bonusSphere.position.set(15, 0, 0);
      bonusGroup.add(bonusSphere);

      const bonusLabelEl = document.createElement('div');
      bonusLabelEl.className = 'label';
      bonusLabelEl.textContent = "Bonus";
      const bonusLabelObj = new THREE.CSS2DObject(bonusLabelEl);
      bonusLabelObj.position.set(0, 2, 0);
      bonusSphere.add(bonusLabelObj);
    }

    // Raycasting
    let raycaster, mouse;
    function initRaycaster(){
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      renderer.domElement.addEventListener('pointermove', onPointerMove, false);
      renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
    }
    function onPointerDown(e){
      e.preventDefault();
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      // Check spikes
      const spikeIntersects = raycaster.intersectObjects(spikeData.map(d => d.mesh), true);
      if (spikeIntersects.length > 0){
        const clickedObj = spikeIntersects[0].object;
        const spikeInfo = spikeData.find(d => d.mesh === clickedObj);
        if (spikeInfo) {
          openQuestionModal(spikeInfo);
          return;
        }
      }

      // Check bonus sphere
      const sphereIntersects = raycaster.intersectObject(bonusSphere, true);
      if (sphereIntersects.length > 0){
        if (!bonusCompleted) {
          bonusAsked = true;
          openBonusModal();
        } else {
          alert("You've already submitted your bonus reasoning!");
        }
      }
    }
    function onPointerMove(e){
      e.preventDefault();
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const objects = spikeData.map(d => d.mesh).concat([bonusSphere]);
      const intersects = raycaster.intersectObjects(objects, true);
      document.body.style.cursor = (intersects.length > 0) ? 'pointer' : 'default';
    }

    /***********************************************
     * BONUS MODAL
     ***********************************************/
    const bonusModalOverlay = document.getElementById('bonusModalOverlay');
    const bonusTextEl = document.getElementById('bonusText');
    document.getElementById('cancelBonusBtn').addEventListener('click', () => {
      bonusModalOverlay.style.display = "none";
      if (getAnsweredCount() === totalQuestions && !bonusCompleted) {
        showFinalResults();
      }
    });
    document.getElementById('submitBonusBtn').addEventListener('click', () => {
      let text = bonusTextEl.value.trim();
      if (text !== ""){
        bonusCompleted = true; 
        bonusText = text; 
        bonusPoints = 0.5;
      } else {
        bonusCompleted = false; 
        bonusPoints = 0;
      }
      bonusModalOverlay.style.display = "none";
      if (getAnsweredCount() === totalQuestions) {
        showFinalResults();
      }
    });
    function openBonusModal(){
      bonusModalOverlay.style.display = "flex";
    }

    /***********************************************
     * QUESTION MODAL
     ***********************************************/
    const modalOverlay = document.getElementById('modalOverlay');
    const modalTitle = document.getElementById('modalTitle');
    const questionNameElModal = document.getElementById('questionName');
    const questionSlider = document.getElementById('questionSlider');
    const questionValueEl = document.getElementById('questionValue');
    const minMaxMarksEl = document.getElementById('minMaxMarks');
    const cancelBtn = document.getElementById('cancelBtn');
    const saveBtn   = document.getElementById('saveBtn');

    questionSlider.addEventListener('input', () => {
      questionValueEl.textContent = questionSlider.value;
    });

    let currentSpikeInfo = null;
    function openQuestionModal(spikeInfo){
      currentSpikeInfo = spikeInfo;
      const cat = categories[spikeInfo.categoryIndex];
      const q   = cat.questions[spikeInfo.questionIndex];

      modalTitle.textContent = cat.name;
      let displayName = q.name;
      if (q.name === "Annoyance Factor") {
        displayName += " (less = more annoying!)";
      } else if (q.name === "Red Flags") {
        displayName += " (less = more red flags!)";
      }
      questionNameElModal.textContent = displayName;

      questionSlider.setAttribute('list', (q.max === 5) ? 'ticks5' : 'ticks10');
      questionSlider.max = q.max;
      minMaxMarksEl.children[0].textContent = '1';
      minMaxMarksEl.children[1].textContent = String(q.max);

      let startVal = (q.value !== null) ? q.value : 1;
      questionSlider.value = startVal;
      questionValueEl.textContent = questionSlider.value;

      modalOverlay.style.display = 'flex';
    }

    cancelBtn.addEventListener('click', () => {
      modalOverlay.style.display = 'none';
      currentSpikeInfo = null;
    });

    saveBtn.addEventListener('click', () => {
      if (currentSpikeInfo){
        const cat = categories[currentSpikeInfo.categoryIndex];
        const q   = cat.questions[currentSpikeInfo.questionIndex];
        let newVal = parseInt(questionSlider.value, 10);
        newVal = Math.min(newVal, q.max); 
        newVal = Math.max(1, newVal);
        q.value = newVal;

        // Visually mark the spike as "answered"
        currentSpikeInfo.mesh.material.color.set(0x888888);
        currentSpikeInfo.mesh.material.emissive.set(0x888888);
        currentSpikeInfo.labelObj.element.style.transform = 'scale(0.8)';
      }
      modalOverlay.style.display = 'none';
      currentSpikeInfo = null;

      updateProgress();
      if (getAnsweredCount() === totalQuestions) {
        if (!bonusAsked && !bonusCompleted) {
          bonusAsked = true;
          let wantBonus = confirm("All questions answered. Want to answer the bonus for +0.5?");
          if (wantBonus){
            openBonusModal();
            return;
          } else {
            showFinalResults();
            return;
          }
        } else if (!bonusCompleted) {
          let wantBonus = confirm("All questions answered. Last chance for bonus. Do it?");
          if (wantBonus){
            openBonusModal();
          } else {
            showFinalResults();
          }
        } else {
          showFinalResults();
        }
      }
    });

    function getAnsweredCount() {
      let count = 0;
      categories.forEach(cat => {
        cat.questions.forEach(q => {
          if (q.value !== null) count++;
        });
      });
      return count;
    }
    function updateProgress(){
      const answered = getAnsweredCount();
      document.getElementById('progressText').textContent = `Questions: ${answered} / ${totalQuestions} answered`;
      let pct = (answered / totalQuestions) * 100;
      document.getElementById('progressBar').style.width = pct + '%';
    }

    /***********************************************
     * FINAL RESULTS
     ***********************************************/
    function showFinalResults(){
      let sumAll = 0;
      let breakdownHTML = "";
      categories.forEach(cat => {
        cat.questions.forEach(q => {
          sumAll += (q.value || 0);
          breakdownHTML += `<li><strong>${cat.name} - ${q.name}:</strong> ${q.value || 0}</li>`;
        });
      });

      let finalScore = (sumAll / 100) * 10;
      if (bonusCompleted) {
        finalScore += 0.5;
      }
      if (finalScore > 10.5) {
        finalScore = 10.5;
      }

      const outOfTen = finalScore.toFixed(1);
      const beholderName = document.getElementById('beholderInput').value || "Unknown";
      const appleName = document.getElementById('appleInput').value || "Unknown";
      let bonusIndicator = bonusCompleted ? "(+ Bonus)" : "";
      let bonusHTML = bonusCompleted ? `<p><strong>Bonus Reasoning:</strong> ${bonusText}</p>` : "";

      finalResultOverlay.innerHTML = `
        <div id="finalResultBox">
          <h2>Your Baddie Score</h2>
          <div id="finalScore">${outOfTen} / 10 <span style="font-size:0.6em;">${bonusIndicator}</span></div>
          <p><strong>Baddie in Control:</strong> ${beholderName}</p>
          <p><strong>Target Name:</strong> ${appleName}</p>
          ${bonusHTML}
          <h3>Breakdown</h3>
          <ul>${breakdownHTML}</ul>
          <button id="closeResultsBtn">Close</button>
        </div>
      `;
      finalResultOverlay.style.display = 'flex';
      document.getElementById('closeResultsBtn').addEventListener('click', () => {
        finalResultOverlay.style.display = 'none';
      });
      launchConfetti();
      blowUpSphere();
    }

    /***********************************************
     * Confetti & Blow-up Effects
     ***********************************************/
    function launchConfetti(){
      myConfetti({ particleCount: 20, angle: 60, spread: 100, origin: { x: 0 } });
      myConfetti({ particleCount: 20, angle: 120, spread: 100, origin: { x: 1 } });
      const duration = 3000;
      const end = Date.now() + duration;
      (function frame(){
        myConfetti({ particleCount: 20, angle: 60,  spread: 100, origin: { x: 0 } });
        myConfetti({ particleCount: 20, angle: 120, spread: 100, origin: { x: 1 } });
        if (Date.now() < end) requestAnimationFrame(frame);
      })();
    }
    function blowUpSphere(){
      blowUpActive = true;
      blowUpStartTime = performance.now();
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
    }

    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);

      if (wedgeGroup){
        wedgeGroup.rotation.y += 0.0024;  
        wedgeGroup.rotation.x += 0.0008;
      }
      if (baddiTextMesh){
        textGroup.rotation.y += 0.015;
      }
      if (bonusGroup){
        bonusGroup.rotation.y += 0.005;
      }

      if (starMaterial){
        const elapsed = clock.getElapsedTime();
        starMaterial.size = 1 + 0.3 * Math.sin(elapsed * 2);
      }
      if (blowUpActive && wedgeGroup){
        const t = (performance.now() - blowUpStartTime) / 1000;
        let scale = 1 + t * 2;
        if (scale >= 3) scale = 3;
        wedgeGroup.scale.set(scale, scale, scale);
      }

      controls.update();
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
